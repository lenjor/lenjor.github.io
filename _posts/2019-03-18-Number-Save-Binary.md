---
layout: post
title: Java中正负数二进制表示
tags: java    
---
<!-- TOC -->

- [在Java/C++中正数和负数的存储方式](#在javac中正数和负数的存储方式)
    - [正码（正数使用）](#正码正数使用)
    - [反码（正码取反）](#反码正码取反)
    - [补码（反码加1）](#补码反码加1)
    - [为什么计算机负数要以补码的形式存储](#为什么计算机负数要以补码的形式存储)

<!-- /TOC -->

### 在Java/C++中正数和负数的存储方式
	正数是以正码的形式存储
	负数是以补码的形式存储

#### 正码（正数使用）
正码就是一个数的真实值

假设有一个 int （32位）类型的数，值为5，那么，我们知道它在计算机中表示为：

	00000000 00000000 00000000 00000101

5转换成二制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。

#### 反码（正码取反）
5的二进制表示为 00000000 00000000 00000000 00000101 ，取反得
	
	00000000 00000000 00000000 00000101		5
	-----------------------------------		~5
	11111111 11111111 11111111 11111010
　

#### 补码（反码加1）
前面说到，5的反码为   	11111111 11111111 11111111 11111010

		11111111 11111111 11111111 11111010			~5
		00000000 00000000 00000000 00000001			1
		-----------------------------------			+
		11111111 11111111 11111111 11111011			补码

在计算机里面，负数才使用补码的形式存储，那么我们举个例子  **-1**
**先取1的正码**（**重点，是1的正码**）：

	00000000 00000000 00000000 00000001
-1的反码：
	
	11111111 11111111 11111111 11111110

-1的补码（反码加1）：

	11111111 11111111 11111111 11111111

可见，－1在计算机里用二进制表达就是全1。16进制为：0xFFFFFFFF

#### 为什么计算机负数要以补码的形式存储
在硬件底层，只有加法器，没有减法器，为什么呢？因为减法在计算机底层也是加法运算，原因就在于**补码可以直接运算**。
	
		11111111 11111111 11111111 11111111		-1
	+	11111111 11111111 11111111 11111011		-5
	---------------------------------------
		11111111 11111111 11111111 11111010		-6的补码表示


		11111111 11111111 11111111 11111111		-1
	+	00000000 00000000 00000000 00000101		5
	---------------------------------------
		00000000 00000000 00000000 00000100		4的正码表示

