---
layout: post
title: Redis缓存相关
tags: Redis
---


### 一、为什么要使用缓存

1. 高性能
    在频繁访问不改变的数据场景中，频繁访问数据库会带来较高的延时，使用缓存可以提升百倍性能

2. 高并发
    单机MySQL的QPS推荐是不超过2000，而Redis可以达到10W+的QPS

### 使用缓存会有哪些问题，有何解决方案

#### 1. [缓存与数据库双写不一致](https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md)

##### （1）串行化：
    读请求和写请求串行化，串到一个内存队列里去
    串行化能保证一定不会出现不一致的情况，但是也会导致系统的吞吐量大幅度降低

##### （2）Cache Aside Pattern：
    读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应
    更新的时候，先更新数据库，然后再删除缓存。

    - 为什么是删除缓存不是更新缓存？
    1、很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。
    2、更新缓存的代价有时候是很高，频繁更新的缓存可能是冷数据

##### 缓存不一致问题及解决方案

1. 问题：先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。

    解决思路：先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。
    因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。

2. 数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。随后数据变更的程序完成了数据库的修改。数据库和缓存中的数据不一样了...

#### 2. [缓存雪崩、缓存穿透、缓存击穿](https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-caching-avalanche-and-caching-penetration.md)

#### 3. [缓存并发竞争](https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-cas.md)

### 使用缓存有哪些注意的地方

1. Key的生成规则
    Redis推荐的Key生成规则：

2. 合理的数据结构

3. 缓存时间

### Redis使用场景有哪些？

1. 缓存
2. 分布式锁
3. 计数器
4. 消息队列
5. 社交关系

### Redis和其他缓存框架的区别


### Redis为什么高性能？
- 纯内存操作
- 核心是基于非阻塞的 IO 多路复用机制
- 单线程反而避免了多线程的频繁上下文切换问题